#+STARTUP: showall indent hidestars

* Stages

- Разбор контракта в AST
- В контракте есть функции, каждая из них - тоже AST
- В каждом statement могут быть имена, по ним мы можем вычислить какие
  statement зависят от каких (но надо отслеживать область видимости). Но
  эти имена могут быть любыми, смысл от этого не поменяется.
- Поэтому мы можем заменить эти имена на номера, смысл кода от этого не
  поменяется.
- Теперь мы можем делать вектора для каждого блока кода
  (функции). Вектор - это хэш блока, в котором имена не
  хэшируются. Считаем, что если у двух блоков хэш совпадает, то и
  семантика этих двух блоков идентична (хотя названия переменных и могут
  быть разными)
- Когда у нас есть набор аудированных хэшей, мы можем к каждому хэшу
  привязать аннотацию. Теперь если хэш есть в базе - то этот блок нет
  смысла проверять по второму разу.
- Существуют особые места, которые при аудите надо внимательно смотреть -
  например, где переводятся токены. Для анализа таких мест мы можем
  составлять правила.

* Intro

Я делаю статический анализатор для солидити - это язык смарт-контрактов в
Etherium. Цель в том чтобы искать уязвимости в криво написанных
контрактах.

* Frame

Я буду делать этот проект как композицию компонентов, главными из которых
являются лексер и парсер.

В качестве тестирования я буду подавать на вход файл с валидными
solidity-конструкциями и ожидаю получить дерево разбора на выходе.

#+BEGIN_SRC lisp :tangle result.lisp :noweb tangle :comments noweb
  (eval-when (:compile-toplevel :load-toplevel :execute)
    (ql:quickload '(:yacc :cl-lex :alexandria :anaphora)))

  (defpackage :sol-parser
    (:use :cl :yacc :cl-lex :alexandria :anaphora))

  (in-package :sol-parser)

  (defmacro bprint (var)
    `(subseq (with-output-to-string (*standard-output*)
               (pprint ,var)) 1))

  (defun lddr (par)
    (if (equal 2 (length par))
        (cons (car par) (lddr (cadr par)))
        par))

  <<lexer>>

  <<parser>>

  ;; (progn
  ;;   (defparameter *clj* (sol-lexer (read-file-into-string "result_test.sol")))
  ;;   (let ((result (parse-with-lexer *clj* *sol-parser*)))
  ;;     ;; (format t "~{~%~A~}" result)
  ;;     ;; (lddr result)
  ;;     (print result)
  ;;     ))

  <<tests>>
#+END_SRC

* Tests

Для тестирования будем генерировать файлы с Solidity-кодом в подпапках
папки ~./tests~.

При тестировании мы будем пробегаться по каждому из них и передавать в
парсер. Если возникнет какая-то ошибка - процесс тестирования остановится
и мы увидим, что произошло.

#+NAME: tests
#+BEGIN_SRC lisp
  (in-package :sol-parser)

  (defun map-subdir (test-dir test-fn)
    (let ((test-subdirs))
      (uiop:collect-sub*directories
       test-dir
       (constantly t)
       (constantly t)
       (lambda (it) (push it test-subdirs)))
      (mapcar test-fn
              test-subdirs)))

  (defun map-subdir-files (test-dir test-fn)
    (let ((test-files))
      (map-subdir test-dir
                  #'(lambda (subdir)
                      (mapcar #'(lambda (x)
                                  (push x test-files))
                              (uiop:directory-files
                               (car (uiop:directory* subdir))))))
      (mapcar test-fn
              (reverse test-files))))

  ;; run-tests
  (map-subdir-files
   "./tests"
   #'(lambda (file)
       (print file)
       (let* ((clj-lex (sol-lexer (alexandria:read-file-into-string file))))
         (print (parse-with-lexer clj-lex *sol-parser*)))))

  ;; Вариант для тестирования конкретного файла
  (funcall #'(lambda (file)
               (print file)
               (let* ((clj-lex (sol-lexer (alexandria:read-file-into-string file))))
                 (print (parse-with-lexer clj-lex *sol-parser*))))
           #P"/home/rigidus/src/solipsism/tests/test_assembly_stmnt.sol")

  ;;; Вариант для получения списка всех лексем конкретного файла
  ;; (let* ((file #P"/home/rigidus/src/solipsism/tests/test_fn_mod_inv.sol")
  ;;        (contents (read-file-into-string file))
  ;;        (clj (sol-lexer contents)))
  ;;   (print contents)
  ;;   (tagbody
  ;;    repeat
  ;;      (multiple-value-bind (one two)
  ;;          (funcall clj)
  ;;        (format t "~%~A : ~A" one (bprint two))
  ;;        (when one
  ;;          (go repeat)))
  ;;      'fin))
#+END_SRC

* Lexer

Минимальный лексер - это просто функция, которая возвращает замыкание. А
парсер уже вызывает это замыкание каждый раз когда хочет получить
следующий токен. Замыкание при каждом вызове возвращает пару значений -
тип токена и его значение.

** DefLex macro

Написание лексера в этом стиле приводит к необходимости писать множество
повторяющихся конструкций, например:

#+BEGIN_EXAMPLE lisp
  (define-string-lexer sol-lexer
    ("\"([^\\\"]|\\.)*?\"" (return (values '%string (string-trim "\"" $@))))
    ("true" (return (values '%true 'true)))
    ("false" (return (values '%false 'false)))
    ...)
#+END_EXAMPLE

Поэтому более лаконично написать макрос, чтобы не повторяться:

#+NAME: def_lex
#+BEGIN_SRC lisp
  (defmacro def-lex (var-name &body body)
    (let ((res))
      (dolist (item body)
        (push `(,(car item) (return (values ,@(cdr item)))) res))
      `(define-string-lexer ,var-name
         ,@(reverse res))))

  ;; (print
  ;;  (macroexpand-1 '(def-lex sol-lexer
  ;;                   ("\"([^\\\"]|\\.)*?\"" '%string (string-trim "\"" $@))
  ;;                   ("true" '%true 'true)
  ;;                   ("false" '%false 'false))))

  ;; =>
  ;; (DEFINE-STRING-LEXER SOL-LEXER
  ;;   ("\"([^\\\"]|\\.)*?\"" (RETURN (VALUES '%STRING (STRING-TRIM "\"" $@))))
  ;;   ("true" (RETURN (VALUES '%TRUE 'TRUE)))
  ;;   ("false" (RETURN (VALUES '%FALSE 'FALSE))))
#+END_SRC

** Lexer tangle

Теперь можно сформировать шаблон в который можно добавлять токены
лексера.

Так как лексер действует "жадно", может случиться ситуация, когда более
специфичный токен может быть "поглощен" менее специфичным. Например,
более специфичный "integer" может быть распознан как "int" и остаток
"eger" вызовет ошибку распознавания. Для предупреждения таких ситуаций
разбор более специфичных токенов переносят в начало, а менее
специфичных - в конец. Один из самых НЕспефичных токенов - это
identifier, он может совпасть с практически любым словом.

По этой причине в шаблоне я добавляю плейсхолдер last_lexer_tokens,
где будут распознаваться неспецифичные токены. Эти токены я буду
добавлять по мере разбора конструкции языка.

#+NAME: lexer
#+BEGIN_SRC lisp :noweb yes
  <<def_lex>>

  (def-lex sol-lexer
    ;; ("//(.*)" (return (values '%comment $@)))
    ;; ("(?s)/\\*(.*)\\*/" (values 'multiline-comment $@)) ;; TODO

    ;; lexer_tokens here
    <<lexer_tokens>>
    <<last_lexer_tokens>>
    )
#+END_SRC

* Parser

Определяя парсер нужно задать грамматику и продукционные
правила. Грамматика большая, поэтому я буду разбивать ее на отдельные
компоненты в направлении сверху-вниз, следуя по конструкциям языка.

При разборе потребуется заполнять компоненты этой функции: терминалы,
правила грамматики и термы.

#+NAME: parser
#+BEGIN_SRC lisp :noweb yes
  (define-parser *sol-parser*
    (:start-symbol %source-unit)
    (:terminals (
                 <<grammar_terminals>>
                 ))

    <<grammar_rules>>

    (%term
     <<grammar_terminals>>
     ))
#+END_SRC

* Language Constructions

В этомя разделе будут перечислены все грамматические конструкции Solidity
которые я хочу разбирать.

** SourceUnit

Начнем с source unit, которым в общем случае выступает sol-файл.

Здесь необходимо применить трюк, который позволяет рекурсивно включать
в грамматическое правило само это правило. Мы будем использовать это
неоднократно далее. Source-unit содержит source-unit-contents, который
в свою очередь может содержать source-unit.

А source-unit-contents в свою очередь может содержать pragma и/или
определение контракта

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%source-unit
   (%source-unit-contents #'(lambda (x) `(:src-last ,x)))
   (%source-unit-contents %source-unit
                          #'(lambda (a b) `(:src-head ,a :src-rest, b)))
   )
  (%source-unit-contents
   (%pragma-definition #'(lambda (x) `(:pragma-def ,x)))
   (%contract-definition #'(lambda (x) `(:contract-def ,x)))
   )
#+END_SRC

** PragmaDefinition

Очень простое правило для распознавание прагмы:

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%pragma-definition
   (%pragma #'(lambda (x) `(:pragma ,x))))
#+END_SRC

Так как прагма - это терминал, нужно добавить ее в список терминалов

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %pragma
#+END_SRC

И нам понадобится добавить этот терминал к лексеру:

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("pragma\\s+([^;]|\\.)*;" '%pragma (subseq $@ 7))
#+END_SRC

Теперь мы можем написать первый тест:

#+NAME: test_pragma
#+BEGIN_SRC solidity :tangle tests/pragma.sol :mkdirp yes
  pragma solidity ^0.8.0;
#+END_SRC

** TODO Import-directive
** ContractDefinition

В одном файле может быть много определений контракта, особенно если мы
получили source unit из нескольких слитых вместе контрактов. Поэтому
здесь мы опять применяем трюк с включением самого правила.

[TODO:gmm] - Пока контракты включают только определения функций, без
переменных контракта.

Здесь есть проблема опережающих объявлений: мы уже хотим тестировать
парсинг контракта, но еще не умеем определять функции. Можно выйти из
этого, определив токен %func-definition-stub, который будет заменять
определение функции для целей тестирования.

[TODO:gmm] - Ради производительности %func-definition-stub можно удалять
автоматически но я пока не стал это реализовывать.

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%contract-definition
   (%contract %identifier |%{| %contract-definition-contents |%}|
              #'(lambda (ctract id l-brak contents r-brak)
                  `(:contract ,id :contents ,contents)))
   )
  (%contract-definition-contents
   (%func-definition #'(lambda (x) `(:func-last ,x)))
   (%func-definition %contract-definition-contents
                     #'(lambda (a b) `(:func-head ,a :func-rest ,b)))
   (%func-definition-stub  #'(lambda (x) `(:func-definition-stub ,x)))
   )
#+END_SRC

Добавим терминалы

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %contract %identifier |%{| |%}| %func-definition-stub
#+END_SRC

и их распознавание в лексер:

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\bcontract\\b" '%contract 'contract)
  ("{" '|%{| '{)
  ("}" '|%}| '})
  ("%%FUNC_DEFINITION_STUB%%" '%func-definition-stub $@)
#+END_SRC

Неспецифичный токен identifier:

#+BEGIN_SRC lisp :noweb-ref last_lexer_tokens
  ("\\b[a-zA-Z$_]+[a-zA-Z0-9$_]*\\b" '%identifier $@)
#+END_SRC

Тест проверяет общую рамочную конструкцию контракта

#+BEGIN_SRC solidity :tangle tests/contract_definition.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_contract_definition
  {
      %%FUNC_DEFINITION_STUB%%
  }
#+END_SRC

** TODO Interface-definition
** TODO Library-definition
** FuncDefinition

Я использую Виртовскую диаграмму, описывающую фунцию отсюда:
https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.functionDefinition

[TODO:gmm] Для функций пока не реализованы следующие возможности:
- fallback/receive
- modifier invocation
- virtual
- override-specifier

В соответствии с диаграммой разбор определения функции может быть
сложным, поэтому лучше будет его разбить на более мелкие и простые для
понимания фрагменты. Эти фрагменты я включу общий шаблон:

#+BEGIN_SRC lisp :noweb yes :noweb-ref grammar_rules
  (%func-definition
   <<func_def_contents>>
   )
#+END_SRC

Здесь следует начать с тестирования простейшего варианта функции:

#+BEGIN_SRC solidity :tangle tests/test_simple_func_def.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_simple_func_def
  {
      function simple_func () ;
  }
#+END_SRC

Если вынести разбор параметров в отдельное правило %pairlist, то этот
простой вариант функции разбирается так:

#+BEGIN_SRC lisp :noweb-ref func_def_contents
  (%func %identifier %parlist |%;|
         #'(lambda (fun id parlist blk)
             `(:fun ,id :parlist ,parlist)))
  (%func %identifier %parlist %block
         #'(lambda (fun id parlist blk)
             `(:fun ,id :parlist ,parlist :block ,blk)))
#+END_SRC

Добавим терминалы:

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %func |%(| |%)| |%;|
#+END_SRC

и их распознавание в лексер:

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\bfunction\\b" '%func 'func)
  ("\\(" '|%(| '|(|)
  ("\\)" '|%)| '|)|)
  (";" '|%;| '|;|)
#+END_SRC

Теперь надо добавить грамматическое правило для %pairlist, которое
разбирает пустой список параметров и будет разбирать неопределенное
кол-во параметров в скобках (non_empty_parameter_list).

#+BEGIN_SRC lisp :noweb yes :noweb-ref grammar_rules
  (%parlist
   (|%(| |%)| #'(lambda (l-brak r-brak) `(:parlist nil)))
   <<non_empty_parameter_list>>
   )
#+END_SRC

Для разбора непустого списка параметров я использую ссылку на
нетерминал %parameter-list:

#+BEGIN_SRC lisp :noweb-ref non_empty_parameter_list
  (|%(| %parameter-list |%)| #'(lambda (l-brak parlist r-brak) `(:parlist ,parlist)))
#+END_SRC

который в свою очередь является рекурсивным правилом, ссылающимся само на
себя:

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%parameter-list
   (%parameter #'(lambda (x) `(:par-lastg ,x)))
   (%parameter |%,| %parameter-list #'(lambda (a b c) `(:par-head ,a :par-rest ,c)))
   )
#+END_SRC

Для его работы необходимо правило %parameter. Я начну с параметра,
который представляет собой только тип и буду дополнять это правило по
мере усложнения формата параметра.

#+BEGIN_SRC lisp :noweb yes :noweb-ref grammar_rules
  (%parameter
   (%type-name #'(lambda (x) `(:par-type ,x)))
   <<parameter_subrules>>
   )
#+END_SRC

В Solidity параметры разделяются запятыми, поэтому нужно добавить в
лексер соответствующую лексему:

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("," '|%,| '|,|)
#+END_SRC

И добавить ее в список терминалов

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  |%,|
#+END_SRC

В Solidity параметр может включать в себя три компонента, из которых ни
один не является обязательным:
- тип переменной
- локация
- идентификатор

Начнем с типа, для него добавим в лексер соответствующие токены

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\buint\\b" '%type-name 'uint)
  ("\\bint\\b" '%type-name 'int)
#+END_SRC

Эти же токены надо добавить в grammar_terminals

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  |%,| %type-name
#+END_SRC

На этом этапе можно сделать тест, содержащий функцию с одним параметром

#+BEGIN_SRC solidity :tangle tests/test_func_with_param.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_func_with_param
  {
      function func_with_param (uint) ;
  }
#+END_SRC

и тест с несколькими параметрами

#+BEGIN_SRC solidity :tangle tests/test_func_with_params.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_func_with_params
  {
      function func_with_params (uint, int) ;
  }
#+END_SRC

Теперь можно вернуться к разбору параметров. Согласно диаграмме
https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.parameterList
следующий вариант указания параметра включает в себя type-name и
идентификатор. Значит теперь можно расширить правило разбора параметра:

#+BEGIN_SRC lisp :noweb-ref parameter_subrules
  (%type-name %identifier
         #'(lambda (a b) `(:par-type ,a :name ,b)))
#+END_SRC

Для этого правила следует составить тест:

#+BEGIN_SRC solidity :tangle tests/test_fn_prm_type_loc_id.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_fn_prm_type_loc_id
  {
      function func (uint param) ;
  }
#+END_SRC

Также нужен тест, который проверяет что ничего не ломается, если
параметров несколько:

#+BEGIN_SRC solidity :tangle tests/test_fn_prms_type_id.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_fn_prms_type_id
  {
      function func (uint param_one, int param_two) ;
  }
#+END_SRC

Согласно той же диаграмме
(https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.parameterList)
существует вариант указания параметра, состоящий из декларации type-name
и data-location. Для этого снова расширим правило параметров:

#+BEGIN_SRC lisp :noweb-ref parameter_subrules
  (%type-name %data-location
              #'(lambda (a b) `(:par-type ,a :data-location ,b)))
#+END_SRC

%data-location - это терминал, его надо добавить в список терминалов:

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %data-location
#+END_SRC

Все его токены надо добавить в лексер:

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\bmemory\\b" '%data-location 'memory)
  ("\\bstorage\\b" '%data-location 'storage)
  ("\\bcalldata\\b" '%data-location 'calldata)
#+END_SRC

Теперь можно писать тесты:

#+BEGIN_SRC solidity :tangle tests/test_fn_prms_type_loc.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_fn_prms_type_loc
  {
      function just_func (uint storage) ;
      function just_func_params (uint storage, int memory) ;
  }
#+END_SRC

Наконец, последний шаг расширения декларации параметра - это разбор
ситуации, когда декларированы все три компонента:
- type-name
- data-location
- identifier

Расширим правило:

#+BEGIN_SRC lisp :noweb-ref parameter_subrules
  (%type-name %data-location %identifier
         #'(lambda (a b c) `(:par-type ,a :data-location ,b :name ,c)))
#+END_SRC

Все компоненты уже есть, так что осталось только написать тесты:

#+BEGIN_SRC solidity :tangle tests/test_fn_prms_type_loc_id.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_fn_prms_type_loc_id
  {
      function just_func (uint storage param_one) ;
      function just_func_params (uint storage par_one, int memory par_two) ;
  }
#+END_SRC


С параметрами мы закончили, теперь перейдем к возвращаемым
значениям. Согласно диаграмме
https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.functionDefinition
возвращаемые значения если наличествуют, то идут после ключевого слова
returns, которое надо добавить в лексер:

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("returns" '%returns 'returns)
#+END_SRC

и список токенов

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %returns
#+END_SRC

Теперь нам необходимо расширить func-definition с помощью retlist:

#+BEGIN_SRC lisp :noweb-ref func_def_contents
  (%func %identifier %parlist %retlist |%;|
         #'(lambda (fun id parlist retlist blk)
             `(:fun ,id :parlist ,parlist :retlist ,retlist)))
  (%func %identifier %parlist %retlist %block
         #'(lambda (fun id parlist retlist blk)
             (print "dbg: ok : func with parlist and retlist block")
             `(:fun ,id :parlist ,parlist :retlist ,retlist :block ,blk)))
#+END_SRC

Retlist представляет из себя два возможных варианта - с пустым списком
возвращаемых значений и непустым. Непустой список воззвращаемых значений
по сути является уже знакомым parameter-list:

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%retlist
   (%returns |%(| |%)| #'(lambda (ret l-brak r-brak) `(:retlist nil)))
   (%returns |%(| %parameter-list |%)| #'(lambda (ret l-brak retlist r-brak)
                                           `(:retlist ,retlist)))
   )
#+END_SRC

Переходим к тестам:

#+BEGIN_SRC solidity :tangle tests/test_fn_rets.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_fn_returns
  {
      function fn_1 (uint storage p_one) returns (uint storage r_one, int memory r_two) ;
      function fn_2 (uint storage p_one, int memory p_two) returns () ;
      function fn_3 (uint p_one, int p_two) returns (uint r_one) ;
  }
#+END_SRC

Следующая важная часть - это то, что в определении функции может
находиться между параметрами функции и возвращаемыми значениями. Там
может быть следующее:
- visibility
- state-mutability
- modifier-invocation
- virtual
- override-specifier

Все эти вещи могут быть вместе или по-отдельности, и все они
необязательны, поэтому лучше их вынести в отдельное мета-правило:

#+BEGIN_SRC lisp :noweb-ref func_def_contents
  (%func %identifier %parlist %fmeta %retlist |%;|
         #'(lambda (fun id parlist fmeta retlist blk)
             `(:fun ,id :parlist ,parlist :fmeta ,fmeta :retlist ,retlist)))
  (%func %identifier %parlist %fmeta %retlist %block
         #'(lambda (fun id parlist fmeta retlist blk)
             `(:fun ,id :parlist ,parlist :fmeta ,fmeta :retlist ,retlist
               :block ,blk)))
#+END_SRC

Эта мета правило является рамочным правилом для всех выше перечисленных
пунктов во всех возможных комбинациях:

#+BEGIN_SRC lisp :noweb yes :noweb-ref grammar_rules
  (%fmeta
   <<fmeta-combination()>>
   )
#+END_SRC

Все эти комбинации генерируются в tangle-time:

#+NAME: fmeta-combination
#+BEGIN_SRC elisp :results output
  (require 'cl)

  (defun accommodations (in)
    (if (equal 1 (length in))
        (list in)
      (loop
       for item in in
       append (let* ((res)
                     (rest (remove item in))
                     (rets (accommodations rest)))
                (loop for ret in rets do
                      (push ret res)
                      (push (append (list item) ret) res))
                res))))

  (let* ((in '(
              %visibility
              %state-mutability
              %modifier-invocation
              %virtual
              %override-specifier
              ))
         (res (remove-duplicates (accommodations in) :test #'equal)))
    ;; (length res))
    (loop for item in res do
          (let ((short-list (mapcar #'(lambda (item)
                                        (substring (symbol-name item) 1 4))
                                    item)))
            (princ (format "(%s\n  #'(lambda %s\n      %s\n"
                           (mapconcat #'(lambda (it)
                                          (symbol-name it))
                                      item " ")
                           short-list
                           (concat "`("
                            (mapconcat #'(lambda (item)
                                           (concat " :"
                                            (substring (symbol-name item) 1) " ,"
                                            (substring (symbol-name item) 1 4) " "))
                                       item "")
                            ")))"))))))
#+END_SRC

Начнем с visibility. Есть четыре варианта, которые мы должны добавить в
лексер:

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\binternal\\b" '%visibility 'internal)
  ("\\bexternal\\b" '%visibility 'external)
  ("\\bprivate\\b" '%visibility 'private)
  ("\\bpublic\\b" '%visibility 'public)
#+END_SRC

%visibility - это терминал, его надо добавить в список терминалов:

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %visibility
#+END_SRC

Попробуем написать тест:

#+BEGIN_SRC solidity :tangle tests/test_fn_visibility.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_fn_visibility
  {
      function fn_1 (uint p_one, int p_two) external returns (uint r_one) ;
      function fn_2 (uint p_one, int p_two) internal returns (uint r_one) ;
  }
#+END_SRC

Следующий модификатор - state-mutability. Добавляем в лексер:

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\bpure\\b" '%state-mutability 'pure)
  ("\\bview\\b" '%state-mutability 'view)
  ("\\bpayable\\b" '%state-mutability 'payable)
#+END_SRC

%state-mutability - это терминал, его надо добавить в список терминалов:

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %state-mutability
#+END_SRC

Тест:

#+BEGIN_SRC solidity :tangle tests/test_fn_state_mutability.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_fn_state_mutability
  {
      function fn_1 (uint p_one, int p_two) external view returns (uint r_one) ;
      function fn_2 (uint p_one, int p_two) internal payable returns (uint r_one) ;
      function fn_3 (uint p_one, int p_two) external view returns (uint r_one) ;
      function fn_4 (uint p_one, int p_two) view private returns (uint r_one) ;
  }
#+END_SRC

Следующий модификатор - virtual. У него в лексере только один вариант:

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\bvirtual\\b" '%virtual 'virtual)
#+END_SRC

Добавляем в список терминалов:

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %virtual
#+END_SRC

Тест:

#+BEGIN_SRC solidity :tangle tests/test_fn_virtual.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_fn_virtual
  {
      function fn_1 (uint p_one, int p_two) virtual returns (uint r_one) ;
      function fn_2 (uint p_one, int p_two) internal virtual returns (uint r_one) ;
      function fn_3 (uint p_one, int p_two) virtual external view returns (uint r_one) ;
      function fn_4 (uint p_one, int p_two) view private virtual returns (uint r_one) ;
  }
#+END_SRC

Следующий модификатор - modifier-invocation. Он тянет за собой
call-agument-list, поэтому нам понадобится раскрывающее правило:

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%modifier-invocation
   (%identifier-path-with-dot %parlist
                      #'(lambda (idpath args) `(:id-path ,idpath :args ,args)))
   )
#+END_SRC

[TODO:gmm] %call-agument-list это что-то сложное, поэтому пока представим
его как %parlist

%identifier-path-with-dot может быть одним идентифактором илиз набором из
идентификаторов, разделенных точками:

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%identifier-path-with-dot
   (%identifier #'(lambda (id) `(:id ,id)))
   (%identifier |%.| %identifier-path-with-dot
                #'(lambda (id-head dot id-rest)
                    (declare (ignore dot))
                    `(:id-head ,id-head :id-rest ,id-rest)))
   )
#+END_SRC

Теперь надо добавить |%.| в список лексем

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\." '|%.| '|%.|)
#+END_SRC

и терминалов

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %|.|
#+END_SRC

Тест:

#+BEGIN_SRC solidity :tangle tests/test_fn_mod_inv.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_fn_mod_inv
  {
      function fn_1 (uint p_one) isOk() returns (uint r_one) ;
      function fn_1 (uint p_one) Obj.isOk() returns (uint r_one) ;
      function fn_1 (uint p_one) One.Two.isOk() returns (uint r_one) ;

  }
#+END_SRC

Следующий модификатор - override-specifier. Он тянет за собой
identifier-path, поэтому нам понадобится раскрывающее правило:

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%override-specifier
   (%override #'(lambda (ovr)
                  (declare (ignore ovr))
                  `(:override nil)))
   (%override |%(| %identifier-path-with-comma |%)|
              #'(lambda (ovr lb id-path rb)
                  (declare (ignore ovr) (ignore lb) (ignore rb))
                  `(:override ,id-path)))
   )
#+END_SRC

%identifier-path-with-comma может быть одним идентифактором илиз набором
из идентификаторов, разделенных точками:

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%identifier-path-with-comma
   (%identifier #'(lambda (id) `(:id ,id)))
   (%identifier |%,| %identifier-path-with-comma
                #'(lambda (id-head dot id-rest)
                    (declare (ignore dot))
                    `(:id-head ,id-head :id-rest ,id-rest)))
   )
#+END_SRC

Теперь надо добавить |%.| в список лексем

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\," '|%,| '|%,|)
#+END_SRC

и терминалов

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %|,|
#+END_SRC

Теперь надо добавить |%override| в список лексем

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\boverride" '%override '%override)
#+END_SRC

и терминалов

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %override
#+END_SRC

Тест:

#+BEGIN_SRC solidity :tangle tests/test_fn_override.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_fn_override
  {
      function fn_1 (uint p_one) override returns (uint r_one) ;
      function fn_1 (uint p_one) override(Base1, Base2) returns (uint r_one) ;
  }
#+END_SRC

** TODO Constant-variable-declaration
** TODO Struct-definition
** TODO Enum-definition
** TODO User-defined-value-type-definition
** TODO Error-definition
** Block

Block может быть:
- пустыми фигурными скобками
- нетерминалом statement в фигурных скобках
- любым количеством нетерминалов вида "unchecked-block", заключенных в
  фигурные скобки, поэтому тут требуется снова применить трюк с
  оборачивающим contents-правилом.

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%block
   (|%{| |%}| #'(lambda (l-brak r-brak)
                  (print "dbg: empty-blk")
                  `(:empty-blk 'empty)))
   (|%{| %stmnt |%}| #'(lambda (l-brak stmnt r-brak) `(:stmnt ,stmnt)))
   (|%{| %unchecked-block-contents |%}|
         #'(lambda (l-brak cont r-brak) `(:unchecked-blk-contents ,cont)))
   )
  (%unchecked-block-contents
   (%unchecked-block #'(lambda (x) `(:unchk-blk-last ,x)))
   (%unchecked-block %unchecked-block-contents
                     #'(lambda (a b)
                         `(:unchk-blk-head ,a :unchk-blk-rest ,b)))
   )
#+END_SRC

В тесте мы проверим, что unchecked-block могут вкладываться друг в
друга.

Наконец сам нетерминал unchecked-block может состоять только из
терминала "unchecked" со следующим за ним нетерминалом "block":

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%unchecked-block
   (%unchecked %block #'(lambda (a b) `(:unchecked-block ,b)))
   )
#+END_SRC

Так как у нас появляется новый нетерминал, его надо добавить в лексер:

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\bunchecked\\b" '%unchecked 'unchecked)
#+END_SRC

и список терминалов

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %unchecked
#+END_SRC

Тест:

#+BEGIN_SRC solidity :tangle tests/test_fn_block.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_fn_unchecked
  {
      function fn_unchecked_1 (uint p_one) returns (uint r_one) ;
      function fn_unchecked_2 (uint p_one) returns (uint r_one) {
          unchecked { }
      }
      function fn_unchecked_3 (uint p_one) returns (uint r_one) {
          unchecked { unchecked { } }
      }
  }
#+END_SRC

** START Statement

Может быть блоком, повторяющимися декларациями переменных,
повторяющимися expression-statement или одним из подвидов statement, например условным оператором:

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%stmnt
   (%block #'(lambda (blk) `(:stmnt-blk ,blk)))
   (%var-decl-stmnt #'(lambda (x) `(:var-decl ,x)))
   (%var-decl-stmnt %stmnt #'(lambda (x y) `(:var-decl ,x :next-stmnt ,y)))
   (%expr-stmnt #'(lambda (x) `(:expr-stmnt ,x)))
   ;; (%expr-stmnt #'(lambda (x y) `(:expr-stmnt ,x :next-stmnt ,y)))
   (%if-stmnt #'(lambda (x) `(:if-stmnt ,x)))
   (%if-stmnt %stmnt #'(lambda (x y) `(:if-stmnt ,x :next-stmnt ,y)))
   (%for-stmnt #'(lambda (x) `(:for-stmnt ,x)))
   (%for-stmnt %stmnt #'(lambda (x y) `(:for-stmnt ,x :next-stmnt ,y)))
   (%while-stmnt #'(lambda (x) `(:while-stmnt ,x)))
   (%while-stmnt %stmnt #'(lambda (x y) `(:while-stmnt ,x :next-stmnt ,y)))
   (%do-while-stmnt #'(lambda (x) `(:dowhile-stmnt ,x)))
   (%do-while-stmnt %stmnt #'(lambda (x y) `(:dowhile-stmnt ,x :next-stmnt ,y)))
   (%cont-stmnt #'(lambda (x) `(:cont-stmnt ,x)))
   (%cont-stmnt %stmnt #'(lambda (x y) `(:cont-stmnt ,x :next-stmnt ,y)))
   (%break-stmnt #'(lambda (x) `(:break-stmnt ,x)))
   (%break-stmnt %stmnt #'(lambda (x y) `(:break-stmnt ,x :next-stmnt ,y)))
   (%try-stmnt #'(lambda (x) `(:try-stmnt ,x)))
   (%try-stmnt %stmnt #'(lambda (x y) `(:try-stmnt ,x :next-stmnt ,y)))
   (%return-stmnt #'(lambda (x) `(:return-stmnt ,x)))
   (%return-stmnt %stmnt #'(lambda (x y) `(:return-stmnt ,x :next-stmnt ,y)))
   (%emit-stmnt #'(lambda (x) `(:emit-stmnt ,x)))
   (%emit-stmnt %stmnt #'(lambda (x y) `(:emit-stmnt ,x :next-stmnt ,y)))
   (%revert-stmnt #'(lambda (x) `(:revert-stmnt ,x)))
   (%revert-stmnt %stmnt #'(lambda (x y) `(:revert-stmnt ,x :next-stmnt ,y)))
   (%assembly-stmnt #'(lambda (x) `(:assembly-stmnt ,x)))
   (%assembly-stmnt %stmnt #'(lambda (x y) `(:assembly-stmnt ,x :next-stmnt ,y)))
   )
#+END_SRC

Тест:

#+BEGIN_SRC solidity :tangle tests/test_statement.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_statement
  {
      function fn_stmnt_1 (uint p_one) returns (uint r_one) {
          { }
      }
  }
#+END_SRC

*** variable-declaration-statement

Декларация переменной может быть одним из следующих вариантов:
- просто декларация, завершающаяся точкой с запятой
- декларация с инициализацией
- декларация тупла с инициализацией

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%var-decl-stmnt
   (%var-decl |%;| #'(lambda (vd sc)
                       `(:var-decl ,vd)))
   (%var-decl |%=| %expr |%;| #'(lambda (vd eq ex sc)
                                  `(:var-decl ,vd :init ,ex)))
   (%var-decl-tuple |%=| %expr |%;| #'(lambda (vd eq ex sc)
                                        `(var-decl-tuple ,vd :init ,ex)))
   )
#+END_SRC

Потребуется добавить в список лексем и терминалов "знак равно":

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("=" '|%=| '|%=|)
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  |%=|
#+END_SRC

**** variable-declaration

%var-decl (объявление переменной) - это объявление ее type-name,
опционально data-location, и идентификатора:

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%var-decl
   (%type-name %identifier #'(lambda (vt vn)
                               `(:var-type ,vt :name ,vn)))
   (%type-name %data-location %identifier
               #'(lambda (vt dl vn)
                   `(:var-type ,vt :data-location ,dl :name ,vn)))
   )
#+END_SRC

Тест:

#+BEGIN_SRC solidity :tangle tests/test_var_decl.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_var_decl
  {
      function fn_var_decl (uint p_one) returns (uint r_one) {
          uint first_var;
          uint memory second_var;
          int init_var_third = 123;
          int memory init_var_fourth = 234;
      }
  }
#+END_SRC

**** variable-declaration-tuple

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%var-decl-tuple
   (|%(| %var-decl |%)| #'(lambda (lb vd rb)
                            `(:var-decl-tuple ,vd)))
   (|%(| %var-decl %one-more-var-decl |%)|
         #'(lambda (lb vd om rb)
             `(:var-decl-tuple ,vd :rest ,om)))
   )
  (%one-more-var-decl
   (|%,| %var-decl #'(lambda (cm vd)
                       `(one-more-var-decl ,vd)))
   (|%,| #'(lambda (cm)
             `(one-more-comma ,cm)))
   (|%,| %var-decl %one-more-var-decl
         #'(lambda (cm vd om)
             `(one-more-var-decl ,vd :rest ,om)))
   (|%,| %one-more-var-decl
         #'(lambda (cm om)
             `(one-more-comma ,cm :rest ,om)))
   )
#+END_SRC

#+BEGIN_SRC solidity :tangle tests/test_var_decl_typle.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_var_decl_tuple
  {
      function fn_var_decl_typle (uint p_one) returns (uint r_one) {
          (int one) = 1;
          (int memory two) = 2;
          (int ab, uint cd) = 3;
          (int ab,) = 4;
          (int ab, uint cd, int ef) = 5;
          (int ab, , ,) = 6;
          (int gh, , uint hi, , uint jk ,) = 7;
      }
  }
#+END_SRC

*** expression-statement

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%expr-stmnt
   (%expr |%;| #'(lambda (ex sc) `(:expr ,ex)))
   )
#+END_SRC

#+BEGIN_SRC solidity :tangle tests/test_expr_stmnt.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_var_decl
  {
      function fn_expr_stmnt (uint p_one) returns (uint r_one) {
          234;
      }
  }
#+END_SRC

*** if-statement

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%if-stmnt
   (%if |%(| %expr |%)| %stmnt
        #'(lambda (ef lb ce rb th) `(if-stmnt ,ce :then ,th)))
   (%if |%(| %expr |%)| %stmnt %else %stmnt
        #'(lambda (ef lb ce rb th el es)
            `(if-stmnt ,ce :then ,th :else ,es)))
   )
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\bif\\b" '%if '%if)
  ("\\belse\\b" '%else '%else)
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %if %else
#+END_SRC

#+BEGIN_SRC solidity :tangle tests/test_if_stmnt.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_if_stmnt
  {
      function fn_if_stmnt (uint p_one) returns (uint r_one) {
          if ( 123 ) 345 ;
          if ( 123 ) { 345; }
          if ( 123 ) 345 ; else 998 ;
          if ( 123 ) { 345 ; } else 998 ;
          if ( 123 ) { 345 ; } else { 998 ; }
      }
  }
#+END_SRC

*** for-statement

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%for-stmnt
   (%for |%(|            |%;|  |%;|                |%)| %stmnt
         #'(lambda (fr lb c1 c2 rb bd)
             `(:for :var nil :cond nil :step nil :body ,bd)))
   (%for |%(| %var-decl-stmnt  |%;|                |%)| %stmnt
         #'(lambda (fr lb c1 c2 rb bd)
             `(:for :var ,c1 :cond nil :step nil :body ,bd)))
   (%for |%(|     %expr-stmnt  |%;|                |%)| %stmnt
         #'(lambda (fr lb c1 c2 rb bd)
             `(:for :var ,c1 :cond nil :step nil :body ,bd)))
   ;;
   (%for |%(|            |%;|  %expr-stmnt         |%)| %stmnt
         #'(lambda (fr lb c1 c2 rb bd)
             `(:for :var nil :cond ,c2 :step nil :body ,bd)))
   (%for |%(| %var-decl-stmnt  %expr-stmnt         |%)| %stmnt
         #'(lambda (fr lb c1 c2 rb bd)
             `(:for :var ,c1 :cond ,c2 :step nil :body ,bd)))
   (%for |%(|     %expr-stmnt  %expr-stmnt         |%)| %stmnt
         #'(lambda (fr lb c1 c2 rb bd)
             `(:for :var ,c1 :cond ,c2 :step nil :body ,bd)))
   ;;
   (%for |%(|            |%;|  |%;|         %expr  |%)| %stmnt
         #'(lambda (fr lb c1 c2 c3 rb bd)
             `(:for :var nil :cond nil :step ,c3 :body ,bd)))
   (%for |%(| %var-decl-stmnt  |%;|         %expr  |%)| %stmnt
         #'(lambda (fr lb c1 c2 c3 rb bd)
             `(:for :var ,c1 :cond ,c2 :step ,c3 :body ,bd)))
   (%for |%(|     %expr-stmnt  |%;|         %expr  |%)| %stmnt
         #'(lambda (fr lb c1 c2 c3 rb bd)
             `(:for :var ,c1 :cond ,c2 :step ,c3 :body ,bd)))
   ;;
   (%for |%(|            |%;|  %expr-stmnt  %expr  |%)| %stmnt
         #'(lambda (fr lb c1 c2 c3 rb bd)
             `(:for :var nil :cond ,c2 :step ,c3 :body ,bd)))
   (%for |%(| %var-decl-stmnt  %expr-stmnt  %expr  |%)| %stmnt
         #'(lambda (fr lb c1 c2 c3 rb bd)
             `(:for :var ,c1 :cond ,c2 :step ,c3 :body ,bd)))
   (%for |%(|     %expr-stmnt  %expr-stmnt  %expr  |%)| %stmnt
         #'(lambda (fr lb c1 c2 c3 rb bd)
             `(:for :var ,c1 :cond ,c2 :step ,c3 :body ,bd)))
   )
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\bfor\\b" '%for '%for)
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %for
#+END_SRC

#+BEGIN_SRC solidity :tangle tests/test_for_stmnt.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_for_stmnt
  {
      function fn_for_stmnt (uint p_one) returns (uint r_one) {
          for (            ;     ; ) 345 ;
          for (            ;     ; ) { 345 ; }
          for ( uint idx   ;     ; ) { 345 ; }
          for ( uint idx=0 ;     ; ) { 345 ; }
          for ( 123        ;     ; ) { 345 ; }

          for (            ; 234 ; ) { 345 ; }
          for ( uint idx=0 ; 234 ; ) { 345 ; }
          for ( 123        ; 234 ; ) { 345 ; }

          for (            ;     ; 987 ) { 345 ; }
          for ( uint idx=0 ;     ; 987 ) { 345 ; }
          for ( 123        ;     ; 987 ) { 345 ; }

          for (            ; 234 ; 987 ) { 345 ; }
          for ( uint idx=0 ; 234 ; 987 ) { 345 ; }
          for ( 123        ; 234 ; 987 ) { 345 ; }
      }
  }
#+END_SRC

*** while-statement

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%while-stmnt
   (%while |%(| %expr |%)| %stmnt
         #'(lambda (wh lb ex rb bd)
             `(:while ,ex :body ,bd)))
   )
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\bwhile\\b" '%while '%while)
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %while
#+END_SRC

#+BEGIN_SRC solidity :tangle tests/test_while_stmnt.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_while_stmnt
  {
      function fn_while_stmnt (uint p_one) returns (uint r_one) {
          while ( 123 ) 345 ;
      }
  }
#+END_SRC

*** do-while-statement

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%do-while-stmnt
   (%do %stmnt %while |%(| %expr |%)| |%;|
         #'(lambda (dd bd wh lb ex rb sc)
             `(:dowhile ,ex :body ,bd)))
   )
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\bdo\\b" '%do '%do)
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %do
#+END_SRC

#+BEGIN_SRC solidity :tangle tests/test_dowhile_stmnt.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_dowhile_stmnt
  {
      function fn_dowhile_stmnt (uint p_one) returns (uint r_one) {
          do { 123 ; } while ( 345 ) ;
          do 123 ; while ( 345 ) ;
      }
  }
#+END_SRC

*** continue-statement

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%cont-stmnt
   (%continue |%;|
         #'(lambda (co sc)
             `(:cont nil)))
   )
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\bcontinue\\b" '%continue '%continue)
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %continue
#+END_SRC

#+BEGIN_SRC solidity :tangle tests/test_continue_stmnt.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_continue_stmnt
  {
      function fn_continue_stmnt (uint p_one) returns (uint r_one) {
          continue ;
      }
  }
#+END_SRC

*** break-statement

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%break-stmnt
   (%break |%;|
         #'(lambda (br sc)
             `(:break nil)))
   )
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\bbreak\\b" '%break '%break)
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %break
#+END_SRC

#+BEGIN_SRC solidity :tangle tests/test_break_stmnt.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_break_stmnt
  {
      function fn_break_stmnt (uint p_one) returns (uint r_one) {
          continue ;
      }
  }
#+END_SRC

*** try-statement and catch-clause

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%try-stmnt
   (%try %expr %block %catch-clause-contents
         #'(lambda (tr ex bl cc)
             `(:try ,ex :blk ,bl :catch ,cc)))
   (%try %expr %returns |%(| %parameter-list |%)| %block %catch-clause-contents
         #'(lambda (tr ex rt lb pl rb bl cc)
             `(:try ,ex :ret ,pl :blk ,bl :catch ,cc)))
   )
  (%catch-clause-contents
   (%catch-clause %catch-clause-contents
                  #'(lambda (a b) `(:catch-head ,a :catch-rest ,b)))
   (%catch-clause #'(lambda (a) `(:catch-last ,a)))
   )
  (%catch-clause
   (%catch %block #'(lambda (ca bl) `(:catch nil :blk ,bl)))
   (%catch |%(| %parameter-list |%)| %block
           #'(lambda (ca lb pl rb bl) `(:catch nil :par-list ,pl :blk ,bl)))
   (%catch %identifier |%(| %parameter-list |%)| %block
           #'(lambda (ca id lb pl rb bl) `(:catch ,id :par-list ,pl :blk ,bl)))
   )
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\btry\\b" '%try '%try)
  ("\\bcatch\\b" '%catch '%catch)
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %try
  %catch
#+END_SRC

#+BEGIN_SRC solidity :tangle tests/test_try_catch_stmnt.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_try_stmnt
  {
      function fn_try_stmnt (uint p_one) returns (uint r_one) {
          try 123 { } catch { }
          try 123 { } catch { } catch { }
          try 123 { } catch (uint memory reason) { }
          try 123 { } catch Error(uint memory reason) { }
          try 123 returns (int memory retval)
              { } catch Error(uint memory reason) { }
      }
  }
#+END_SRC

*** return-statement

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%return-stmnt
   (%return |%;|
         #'(lambda (rt sc)
             `(:return nil)))
   (%return %expr |%;|
            #'(lambda (rt ex sc)
                `(:return ,ex)))
   )
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\breturn\\b" '%return '%return)
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %return
#+END_SRC

#+BEGIN_SRC solidity :tangle tests/test_return_stmnt.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_return_stmnt
  {
      function fn_return_stmnt (uint p_one) returns (uint r_one) {
          return ;
          return 123 ;
      }
  }
#+END_SRC

*** emit-statement

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%emit-stmnt
   (%emit %expr %call-arg-list |%;|
            #'(lambda (et ex al sc)
                `(:emit ,ex, :args ,al)))
   )
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\bemit\\b" '%emit '%emit)
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %emit
#+END_SRC

#+BEGIN_SRC solidity :tangle tests/test_emit_stmnt.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_emit_stmnt
  {
      function fn_emit_stmnt (uint p_one) returns (uint r_one) {
          emit 123 ( ) ;
          emit 123 ( 321 ) ;
          emit 123 ( 321, 432 ) ;
          emit 123 ( { } ) ;
          emit 123 ( { Log : 987 } ) ;
          emit 123 ( { Log : 987, Some : 765 } ) ;
      }
  }
#+END_SRC

*** revert-statement

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%revert-stmnt
   (%revert %expr %call-arg-list |%;|
            #'(lambda (et ex al sc)
                `(:emit ,ex, :args ,al)))
   )
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\brevert\\b" '%revert '%revert)
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %revert
#+END_SRC

#+BEGIN_SRC solidity :tangle tests/test_revert_stmnt.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_revert_stmnt
  {
      function fn_revert_stmnt (uint p_one) returns (uint r_one) {
          revert 123 ( ) ;
          revert 123 ( 321 ) ;
          revert 123 ( 321, 432 ) ;
          revert 123 ( { } ) ;
          revert 123 ( { Log : 987 } ) ;
          revert 123 ( { Log : 987, Some : 765 } ) ;
      }
  }
#+END_SRC

*** START assembly-statement

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%assembly-stmnt
   (%assembly |%{| |%}| #'(lambda (as lb rb) `(:asm-empty nil)))
   (%assembly |%{| yul-stmnt |%}| #'(lambda (as lb yu rb) `(:asm ,yu)))
   (%assembly %evmasm |%{|  |%}| #'(lambda (as em lb rb) `(:asm-empty ,yu)))
   (%assembly %evmasm |%{| yul-stmnt |%}| #'(lambda (as em lb yu rb) `(:asm nil)))
   )
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("\\bassembly\\b" '%assembly '%assembly)
  ("\"evmasm\"" '%evmasm '%evmasm)
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %assembly %evmasm
#+END_SRC

#+BEGIN_SRC solidity :tangle tests/test_assembly_stmnt.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_assembly_stmnt
  {
      function fn_assembly_stmnt (uint p_one) returns (uint r_one) {
          assembly "evmasm" { }
      }
  }
#+END_SRC

**** TODO Yul-statement
***** TODO yul-block
***** TODO yul-variable-declaration
***** TODO yul-assignment
***** TODO yul-function-call
***** TODO yul-if-statement
***** TODO yul-for-statement
***** TODO yul-switch-statementleavebreakcontinue
***** TODO yul-function-definition

** Call-argument-list

Arguments when calling a function or a similar callable object. The
arguments are either given as comma separated list or as map of named
arguments.

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%call-arg-list
   (|%(| |%)| #'(lambda (lb rb) `(:call-arg-list nil)))
   (|%(| %call-arg-expr |%)| #'(lambda (lb ex rb) `(:call-arg-list ,ex)))
   (|%(| |%{|  |%}| |%)|
         #'(lambda (lb lc rc rb) `(:call-arg-list-empty nil)))
   (|%(| |%{| %call-arg-obj |%}| |%)|
         #'(lambda (lb lc ob rc rb) `(:call-arg-list ,ob)))
   )
  (%call-arg-expr
   (%expr #'(lambda (a) `(:call-arg-expr-last ,a)))
   (%expr |%,| %call-arg-expr
          #'(lambda (ex cm nx)
              `(:call-arg-expr-head ,ex :call-arg-expr-rest ,nx)))
   )
  (%call-arg-obj
   (%identifier |%:| %expr #'(lambda (id cm ex)
                               `(:call-arg-obj-last ,id :call-expr ,ex)))
   (%identifier |%:| %expr |%,| %call-arg-obj
                #'(lambda (id cm ex sc rt)
                    `(:call-arg-obj-head ,id :call-expr ,ex
                      :call-arg-obj-head ,rt)))
   )
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  (":" '|%:| '|:|)
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  |%:|
#+END_SRC

** START Expression

Это один из самых сложных нетерминалов

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%expr
   (%lit #'(lambda (x) `(:expr ,x)))
   ;; ...
   )
#+END_SRC

*** TODO Literal

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%lit
   ;; (%str-lit #'(lambda (lt)
   ;;               `(:expr-lit ,vt :name ,vn)))/
   (%num-lit #'(lambda (lt)
                 `(:lit ,lt)))
   ;; (%bool-lit #'(lambda (lt)
   ;;                `(:expr-bool-lit ,lt)))
   ;; (%hex-str-litl #'(lambda (lt)
   ;;                    `(:expr-hex-str-lit ,lt)))
   ;; (%unicode-str-lit #'(lambda (lt)
   ;;            `(:expr-unicode-str-lit ,lt))).
   )
#+END_SRC

**** TODO Number-literal

Числовые литералы могут быть либо десятичными либо шестнадцатиричными,
при этом могут иметь опциональный number-unit

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%num-lit
   (%dec-num #'(lambda (lt) `(:num-lit ,lt)))
   ;; (%dec-num %num-unit #'(lambda (lt nu)
   ;;                         `(:dec-num ,lt :num-unit ,nu)))
   ;; (%hex-num #'(lambda (lt) `(:hex-number ,lt)))
   ;; (%hex-num %num-unit #'(lambda (lt nu)
   ;;                         `(:hex-num ,lt :num-unit ,nu)))
   )
#+END_SRC

***** TODO Decimal-number

может быть:
- набором из цифр и знаков подчеркивания (regex: [0-9_])
- или парой из таких наборов, разделенных точкой

За этим всем может следовать экспоненциальная часть, которая состоит
из большой или маленькой буквы "е", опционального минуса и снова
набора из цифр и знаков подчеркивания.

Поэтому, первое что понадобится - это этот набор. Его надо разместить
в last_lexer_tokens:

#+BEGIN_SRC lisp :noweb-ref last_lexer_tokens
  ("\\b[0-9_]+\\b" '%dec_num_v1 $@)
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %dec_num_v1
#+END_SRC

Там же можно построить пару этих наборов, разделенную точкой:

#+BEGIN_SRC lisp :noweb-ref last_lexer_tokens
  ;; ("\\b[0-9_]+\\\\.[0-9_]+\\b" '%dec_num_v2 $@)
#+END_SRC

Теперь построим набор с последующий экспонециальной частью

#+BEGIN_SRC lisp :noweb-ref last_lexer_tokens
  ;; ("\\b[0-9_]+[eE]+[-]*[0-9_]+\\b" '%dec_num_v3 $@)
#+END_SRC

И то самое, но для двух наборов, разделенных точкой:

#+BEGIN_SRC lisp :noweb-ref last_lexer_tokens
  ;; ("\\b[0-9_]+\\\\.[0-9_]+[eE]+[-]*[0-9_]+\\b" '%dec_num_v4 $@)
#+END_SRC

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%dec-num
   (%dec_num_v1 #'(lambda (dn) `(:dec-num ,dn)))
   ;; (%dec-num %num-unit #'(lambda (lt nu)
   ;;                         `(:dec-num ,lt :num-unit ,nu)))
   ;; (%hex-num #'(lambda (lt) `(:hex-number ,lt)))
   ;; (%hex-num %num-unit #'(lambda (lt nu)
   ;;                         `(:hex-num ,lt :num-unit ,nu)))
   )
#+END_SRC

* Макросы для корректного вывода ошибок

#+NAME: macro_bprint
#+BEGIN_SRC lisp
  (defmacro bprint (var)
    `(subseq (with-output-to-string (*standard-output*)  (pprint ,var)) 1))
#+END_SRC

#+NAME: macro_err
#+BEGIN_SRC lisp
  (defmacro err (var)
    `(error (format nil "ERR:[~A]" (bprint ,var))))
#+END_SRC

* Отладочный вывод

#+NAME: dbgout
#+BEGIN_SRC lisp
  (defparameter *dbg-enable* t)
  (defparameter *dbg-indent* 1)

  (defun dbgout (out)
    (when *dbg-enable*
      (format t (format nil "~~%~~~AT~~A" *dbg-indent*) out)))

  (defmacro dbg (frmt &rest params)
    `(dbgout (format nil ,frmt ,@params)))
#+END_SRC

* Макросы для преобразования порядка аргументов

#+NAME: macro_clj
#+BEGIN_SRC lisp
  (defmacro -> (x &optional form &rest more)
    "Thread the expr through the forms. Insert X as the second item
  in the first form, making a list of it if it is not a list
  already. If there are more forms, insert the first form as the
  second item in second form, etc."
    (cond
      ((null form) x)
      ((null more) (if (listp form)
                       `(,(car form) ,x ,@(cdr form))
                       (list form x)))
      (:else `(-> (-> ,x ,form) ,@more))))

  ;; (-> 5 1- ODDP)
  ;; => (-> (-> 5 1-) ODDP)
  ;; => (ODDP (-> 5 1-))
  ;; => (ODDP (1- 5))

  ;; (sb-cltl2:macroexpand-all '(-> 'first (cons 'second) (cons 'third)))
  ;; => (CONS (CONS 'FIRST 'SECOND) 'THIRD)

  (defmacro ->> (x &optional form &rest more)
    "Thread the expr through the forms. Insert X as the last item
  in the first form, making a list of it if it is not a list
  already. If there are more forms, insert the first form as the
  last item in second form, etc."
    (cond
      ((null form) x)
      ((null more) (if (listp form)
                       `(,@form ,x)
                       (list form x)))
      (:else `(->> (->> ,x ,form) ,@more))))

  ;; (sb-cltl2:macroexpand-all '(->> 'first (cons 'second) (cons 'third)))
  ;; => (CONS 'THIRD (CONS 'SECOND 'FIRST))
#+END_SRC
