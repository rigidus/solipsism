#+STARTUP: showall indent hidestars

* Stages

- Разбор контракта в AST
- В контракте есть функции, каждая из них - тоже AST
- В каждом statement могут быть имена, по ним мы можем вычислить какие
  statement зависят от каких (но надо отслеживать область видимости). Но
  эти имена могут быть любыми, смысл от этого не поменяется.
- Поэтому мы можем заменить эти имена на номера, смысл кода от этого не
  поменяется.
- Теперь мы можем делать вектора для каждого блока кода
  (функции). Вектор - это хэш блока, в котором имена не
  хэшируются. Считаем, что если у двух блоков хэш совпадает, то и
  семантика этих двух блоков идентична (хотя названия переменных и могут
  быть разными)
- Когда у нас есть набор аудированных хэшей, мы можем к каждому хэшу
  привязать аннотацию. Теперь если хэш есть в базе - то этот блок нет
  смысла проверять по второму разу.
- Существуют особые места, которые при аудите надо внимательно смотреть -
  например, где переводятся токены. Для анализа таких мест мы можем
  составлять правила.
* Intro

Я делаю статический анализатор для солидити - это язык смарт-контрактов в
Etherium. Цель в том чтобы искать уязвимости в криво написанных
контрактах.

* Frame

Я буду делать этот проект как композицию компонентов, главными из которых
являются лексер и парсер.

В качестве тестирования я буду подавать на вход файл с валидными
solidity-конструкциями и ожидаю получить дерево разбора на выходе.

#+BEGIN_SRC lisp :tangle result.lisp :noweb tangle :comments noweb
  (eval-when (:compile-toplevel :load-toplevel :execute)
    (ql:quickload '(:yacc :cl-lex :alexandria :anaphora)))

  (defpackage :sol-parser
    (:use :cl :yacc :cl-lex :alexandria :anaphora))

  (in-package :sol-parser)

  (defmacro bprint (var)
    `(subseq (with-output-to-string (*standard-output*)
               (pprint ,var)) 1))

  (defun lddr (par)
    (if (equal 2 (length par))
        (cons (car par) (lddr (cadr par)))
        par))

  <<lexer>>

  ;; (defparameter *clj* (sol-lexer (read-file-into-string "result_test.sol")))

  ;; ;; main
  ;; (tagbody
  ;;  repeat
  ;;    (multiple-value-bind (one two)
  ;;        (funcall *clj*)
  ;;      (format t "~%~A : ~A" one (bprint two))
  ;;      (when one
  ;;        (go repeat)))
  ;;    'fin)

  <<parser>>

  ;; (progn
  ;;   (defparameter *clj* (sol-lexer (read-file-into-string "result_test.sol")))
  ;;   (let ((result (parse-with-lexer *clj* *sol-parser*)))
  ;;     ;; (format t "~{~%~A~}" result)
  ;;     ;; (lddr result)
  ;;     (print result)
  ;;     ))

  <<tests>>
#+END_SRC

* Tests

Для тестирования будем генерировать файлы с Solidity-кодом в подпапках
папки ~./tests~.

При тестировании мы будем пробегаться по каждому из них и передавать в
парсер. Если возникнет какая-то ошибка - процесс тестирования остановится
и мы увидим, что произошло.

#+NAME: tests
#+BEGIN_SRC lisp
  (in-package :sol-parser)

  (defun map-subdir (test-dir test-fn)
    (let ((test-subdirs))
      (uiop:collect-sub*directories
       test-dir
       (constantly t)
       (constantly t)
       (lambda (it) (push it test-subdirs)))
      (mapcar test-fn
              test-subdirs)))

  (defun map-subdir-files (test-dir test-fn)
    (let ((test-files))
      (map-subdir test-dir
                  #'(lambda (subdir)
                      (mapcar #'(lambda (x)
                                  (push x test-files))
                              (uiop:directory-files subdir))))
      (mapcar test-fn
              (reverse test-files))))

  ;; run-tests
  (map-subdir-files
   "./tests"
   #'(lambda (file)
       (print file)
       (let* ((clj-lex (sol-lexer (alexandria:read-file-into-string file))))
         (print (parse-with-lexer clj-lex *sol-parser*)))))
#+END_SRC

[TODO:gmm] - Временные тесты, после переноса в тестовые файлы их можно
будет удалить.

#+BEGIN_SRC solidity :tangle no :aa result_test.sol :noweb tangle :padline no
  pragma solidity ^0.8.0;
  pragma solidity ^0.8.1;
  contract one {
      function alfa () { return; }
  }
  contract two {
      function beta (uint) { return 1; }
      function gamma (uint, uint) { return 2; }
      function delta (uint, uint, uint) { return 3; }
      function epsilon (uint memory) { return 3; }
      function zeta (uint memory, uint storage) { return 4; }
      function eta (uint memory, uint storage, uint calldata) { return 5; }
  }
  contract three {
      function theta (int) { return 6; }
      function theta (int calldata, uint storage) { return 7; }
      function iota (uint storage foo) { return 8; }
      function kappa (uint storage foo, uint memory bar) { return 9; }
  }
  contract four {
      function lambda () returns () { return; }
      function mu () returns (int)  { return 10; }
      function nu () returns (int, int)  { return 11; }
      function xi () internal returns (int, int)  { return 12; }
      function omicron () internal pure returns (int, int)  { return 13; }
      function omicron () pure returns (int, int)  { return 13; }
  }
#+END_SRC

* Lexer

Минимальный лексер - это просто функция, которая возвращает замыкание. А
парсер уже вызывает это замыкание каждый раз когда хочет получить
следующий токен. Замыкание при каждом вызове возвращает пару значений -
тип токена и его значение.

** DefLex macro

Написание лексера в этом стиле приводит к необходимости писать множество
повторяющихся конструкций, например:

#+BEGIN_EXAMPLE lisp
  (define-string-lexer sol-lexer
    ("\"([^\\\"]|\\.)*?\"" (return (values '%string (string-trim "\"" $@))))
    ("true" (return (values '%true 'true)))
    ("false" (return (values '%false 'false)))
    ...)
#+END_EXAMPLE

Поэтому более лаконично написать макрос, чтобы не повторяться:

#+NAME: def_lex
#+BEGIN_SRC lisp
  (defmacro def-lex (var-name &body body)
    (let ((res))
      (dolist (item body)
        (push `(,(car item) (return (values ,@(cdr item)))) res))
      `(define-string-lexer ,var-name
         ,@(reverse res))))

  ;; (print
  ;;  (macroexpand-1 '(def-lex sol-lexer
  ;;                   ("\"([^\\\"]|\\.)*?\"" '%string (string-trim "\"" $@))
  ;;                   ("true" '%true 'true)
  ;;                   ("false" '%false 'false))))

  ;; =>
  ;; (DEFINE-STRING-LEXER SOL-LEXER
  ;;   ("\"([^\\\"]|\\.)*?\"" (RETURN (VALUES '%STRING (STRING-TRIM "\"" $@))))
  ;;   ("true" (RETURN (VALUES '%TRUE 'TRUE)))
  ;;   ("false" (RETURN (VALUES '%FALSE 'FALSE))))
#+END_SRC

** Lexer tangle

Теперь можно сформировать шаблон в который можно добавлять токены
лексера.

Так как лексер действует "жадно", может случиться ситуация, когда более
специфичный токен может быть "поглощен" менее специфичным. Например,
более специфичный "integer" может быть распознан как "int" и остаток
"eger" вызовет ошибку распознавания. Для предупреждения таких ситуаций
разбор более специфичных токенов переносят в начало, а менее
специфичных - в конец. Один из самых НЕспефичных токенов - это
identifier, он может совпасть с практически любым словом.

По этой причине в шаблоне я добавляю плейсхолдер last_lexer_tokens, где
будут распознаваться неспецифичные токены.

#+NAME: lexer
#+BEGIN_SRC lisp :noweb yes
  <<def_lex>>

  (def-lex sol-lexer
    ;; ("//(.*)" (return (values '%comment $@)))
    ;; ("(?s)/\\*(.*)\\*/" (values 'multiline-comment $@)) ;; TODO

    ;; lexer_tokens here
    <<lexer_tokens>>
    <<last_lexer_tokens>>
    )
#+END_SRC

Эти токены я буду добавлять по мере разбора конструкции языка.

[TODO:gmm] - Временно добавим все токены отсюда:

#+BEGIN_SRC lisp :noweb-ref lexer_tokens-
  ("\"([^\\\"]|\\.)*?\"" '%string (string-trim "\"" $@))
  ("true" '%true 'true)
  ("false" '%false 'false)
  ;; ("contract" '%contract 'contract)

  ("internal" '%visibility 'internal)
  ("external" '%visibility 'external)
  ("private" '%visibility 'private)
  ("public" '%visibility 'public)

  ("uint" '%type 'uint)
  ("int" '%type 'int)

  ("function" '%func 'func)

  ("memory" '%data-location 'memory)
  ("storage" '%data-location 'storage)
  ("calldata" '%data-location 'calldata)

  ("pure" '%state-mutability 'pure)
  ("view" '%state-mutability 'view)
  ("payable" '%state-mutability 'payable)

  ;; ("pragma\\s+([^;]|\\.)*;" '%pragma (subseq $@ 7))
  ("\\(" '|%(| '|(|)
  ("\\)" '|%)| '|)|)
  ;; ("{" '|%{| '{)
  ;; ("}" '|%}| '})
  ;; (","
   '|%,| '|,|)
  ("returns" '%returns 'returns)
  ("return" '%return 'return)
  ("-?0|[1-9][0-9]*(\\.[0-9]*)?([e|E][+-]?[0-9]+)?" '%number (read-from-string $@))
  ("[a-zA-Z0-9_]+" '%identifier $@)
  ;; (";" '|%;| '|;|)
#+END_SRC

* Parser

Определяя парсер нужно задать грамматику и продукционные
правила. Грамматика большая, поэтому я буду разбивать ее на отдельные
компоненты в направлении сверху-вниз, следуя по конструкциям языка.

При разборе потребуется заполнять компоненты этой функции: терминалы,
правила грамматики и термы.

#+NAME: parser
#+BEGIN_SRC lisp :noweb yes
  (define-parser *sol-parser*
    (:start-symbol %source-unit)
    (:terminals (
                 <<grammar_terminals>>
                 ))

    <<grammar_rules>>

    (%term
     <<grammar_terminals>>
     ))
#+END_SRC

* Language Constructions

В этомя разделе будут перечислены все грамматические конструкции Solidity
которые я хочу разбирать.

** SourceUnit

Начнем с source unit, которым в общем случае выступает sol-файл.

Здесь необходимо применить трюк, который позволяет рекурсивно включать в
грамматическое правило само это правило. Мы будем использовать это неоднократно
далее. Source-unit содержит source-unit-contents, который в свою очередь
может содержать source-unit.

А source-unit-contents в свою очередь может содержать pragma и/или
определение контракта

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%source-unit
   (%source-unit-contents #'(lambda (x) `(:src-last ,x)))
   (%source-unit-contents %source-unit #'(lambda (a b) `(:src-head ,a :src-rest, b)))
   )
  (%source-unit-contents
   (%pragma-definition #'(lambda (x) `(:pragma-def ,x)))
   (%contract-definition #'(lambda (x) `(:contract-def ,x)))
   )
#+END_SRC

** PragmaDefinition

Очень простое правило для распознавание прагмы:

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%pragma-definition
   (%pragma #'(lambda (x) `(:pragma ,x))))
#+END_SRC

Так как прагма - это терминал, нужно добавить ее в список терминалов

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %pragma
#+END_SRC

И нам понадобится добавить этот терминал к лексеру:

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("pragma\\s+([^;]|\\.)*;" '%pragma (subseq $@ 7))
#+END_SRC

Теперь мы можем написать первый тест:

#+NAME: test_pragma
#+BEGIN_SRC solidity :tangle tests/pragma.sol :mkdirp yes
  pragma solidity ^0.8.0;
#+END_SRC

** ContractDefinition

В одном файле может быть много определений контракта, особенно если мы
получили source unit из нескольких слитых вместе контрактов. Поэтому
здесь мы опять применяем трюк с включением самого правила.

[TODO:gmm] - Пока контракты включают только определения функций, без
переменных контракта.

Здесь есть проблема опережающих объявлений: мы уже хотим тестировать
парсинг контракта, но еще не умеем определять функции. Можно выйти из
этого, определив токен %func-definition-stub, который будет заменять
определение функции для целей тестирования.

[TODO:gmm] - Ради производительности %func-definition-stub можно удалять
автоматически но я пока не стал это реализовывать.

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%contract-definition
   (%contract %identifier |%{| %contract-definition-contents |%}|
              #'(lambda (ctract id l-brak contents r-brak)
                  `(:contract ,id :contents ,contents)))
   )
  (%contract-definition-contents
   (%func-definition #'(lambda (x) `(:func-last ,x)))
   (%func-definition %contract-definition-contents
                     #'(lambda (a b) `(:func-head ,a :func-rest ,b)))
   (%func-definition-stub  #'(lambda (x) `(:func-definition-stub ,x)))
   )
#+END_SRC

Добавим терминалы

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %contract %identifier |%{| |%}| %func-definition-stub
#+END_SRC

и их распознавание в лексер:

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("contract" '%contract 'contract)
  ("{" '|%{| '{)
  ("}" '|%}| '})
  ("%%FUNC_DEFINITION_STUB%%" '%func-definition-stub $@)
#+END_SRC

Неспецифичный токен identifier:

#+BEGIN_SRC lisp :noweb-ref last_lexer_tokens
  ("[a-zA-Z0-9_]+" '%identifier $@)
#+END_SRC

Тест проверяет общую рамочную конструкцию контракта

#+BEGIN_SRC solidity :tangle tests/contract_definition.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_contract_definition
  {
      %%FUNC_DEFINITION_STUB%%
  }
#+END_SRC

** TODO FuncDefinition

Я использую Виртовскую диаграмму, описывающую фунцию отсюда:
https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.functionDefinition

[TODO:gmm] Для функций пока не реализованы следующие возможности:
- fallback/receive
- modifier invocation
- virtual
- override-specifier

В соответствии с диаграммой разбор определения функции может быть
сложным, поэтому лучше будет его разбить на более мелкие и простые для
понимания фрагменты. Эти фрагменты я включу общий шаблон:

#+BEGIN_SRC lisp :noweb yes :noweb-ref grammar_rules
  (%func-definition
   <<func_def_contents>>
   )
#+END_SRC

Здесь следует начать с тестирования простейшего варианта функции:

#+BEGIN_SRC solidity :tangle tests/func_definition.sol :mkdirp yes :noweb yes
  <<test_pragma>>
  contract test_function_definition_001
  {
      function fun_001 () ;
  }
#+END_SRC

Если вынести разбор параметров в отдельное правило %pairlist, то этот
простой вариант функции разбирается просто:

#+BEGIN_SRC lisp :noweb-ref func_def_contents
  (%func %identifier %parlist |%;|
         #'(lambda (fun id parlist semicolon)
             `(:fun ,id :parlist ,parlist)))
#+END_SRC

Но следует добавить грамматическое правило для %pairlist, которое
разбирает пустой список параметров и [TODO:gmm] будет разбирать
неопределенное кол-во параметров в скобках (non_empty_parameter_list).

#+BEGIN_SRC lisp :noweb-ref grammar_rules
  (%parlist
   (|%(| |%)| #'(lambda (l-brak r-brak) `(:parlist nil)))
   <<non_empty_parameter_list>>
   ;;  (|%(| %parameter-list |%)| #'(lambda (l-brak parlist r-brak) `(:parlist ,parlist)))
   )
#+END_SRC

[TODO:gmm] - Оставшиеся неразобранными варианты разбора определения функции

#+BEGIN_SRC lisp :noweb-ref grammar_rules-
  (%func-definition
   ;; (%func %identifier %parlist %state-mutability %retlist %block
   ;;        #'(lambda (fun id parlist mutab retlist blk)
   ;;            `(:fun ,id :parlist ,parlist
   ;;              :state-mutability ,mutab
   ;;              :retlist ,retlist :blk ,blk)))
   ;; (%func %identifier %parlist %visibility %state-mutability %retlist %block
   ;;        #'(lambda (fun id parlist vis mutab retlist blk)
   ;;            `(:fun ,id :parlist ,parlist :visibility ,vis
   ;;              :state-mutability ,mutab
   ;;              :retlist ,retlist :blk ,blk)))
   ;; (%func %identifier %parlist %visibility %retlist %block
   ;;        #'(lambda (fun id parlist vis retlist blk)
   ;;            `(:fun ,id :parlist ,parlist :visibility ,vis :retlist ,retlist :blk ,blk)))
   ;; (%func %identifier %parlist %block
   ;;        #'(lambda (fun id parlist blk)
   ;;            `(:fun ,id :parlist ,parlist :blk ,blk)))
   ;; (%func %identifier %parlist %retlist %block
   ;;        #'(lambda (fun id parlist retlist blk)
   ;;            `(:fun ,id :parlist ,parlist :retlist ,retlist :blk ,blk)))
   )
#+END_SRC

Она тянет за собой вспомогательные правила для суб-конструкций:

#+BEGIN_SRC lisp :noweb-ref grammar_rules

  ;; (%retlist
  ;;  (%returns |%(| |%)| #'(lambda (ret l-brak r-brak) `(:retlist nil)))
  ;;  (%returns |%(| %parameter-list |%)| #'(lambda (ret l-brak retlist r-brak)
  ;;                                          `(:retlist ,retlist)))
  ;;  )
  ;; (%parameter-list
  ;;  (%parameter #'(lambda (x) `(:par-last ,x)))
  ;;  (%parameter |%,| %parameter-list #'(lambda (a b c) `(:par-head ,a :par-rest ,c)))
  ;;  )
  ;; (%parameter
  ;;  (%type #'(lambda (x) `(:par-type ,x)))
  ;;  (%type %data-location #'(lambda (a b) `(:par-type ,a :data-location ,b)))
  ;;  (%type %data-location %identifier
  ;;         #'(lambda (a b c) `(:par-type ,a :data-location ,b :name ,c)))
  ;;  )
  ;; (%block
  ;;  (|%{| |%}| #'(lambda (a b) `(:block-empty ,b)))
  ;;  (|%{| %statement |%}| #'(lambda (a b c) `(:block ,b)))
  ;;  )
  ;; (%statement
  ;;  (%return-statement #'(lambda (x) `(:ret-stmt ,x)))
  ;;  )
  ;; (%return-statement
  ;;  (%return %number |%;| #'(lambda (a b c) `(:ret ,b)))
  ;;  (%return |%;| #'(lambda (a b) `(:ret-empty)))
  ;;  )
#+END_SRC

Добавим терминалы:

#+BEGIN_SRC lisp :noweb-ref grammar_terminals
  %func |%(| |%)| |%;|
#+END_SRC

  %number %visibility %state-mutability %returns %return |%;| |%{| |%}| %func |%(| |%)| |%,| %type %data-location

и их распознавание в лексер:

#+BEGIN_SRC lisp :noweb-ref lexer_tokens
  ("function" '%func 'func)
  ("\\(" '|%(| '|(|)
  ("\\)" '|%)| '|)|)
  (";" '|%;| '|;|)
#+END_SRC

** TODO Functions

#+NAME: function_definition
#+BEGIN_SRC lisp
#+END_SRC

#+NAME: function_definition_rule
#+BEGIN_SRC lisp :noweb-ref rules
  (defun function_definition_rule (fun id l-brak par-lst r-brak blk)
    (declare (ignore fun l-brak r-brak))
    (let ((res))
      (block ppp
        (labels ((tst (lst)
                   (if (null lst)
                       (return-from ppp)
                       (progn
                         (push (car lst) res)
                         (tst (caddr lst))))))
          (tst par-lst)))
      `(:fun ,id ,(reverse res) ,blk)))
#+END_SRC

* Макросы для корректного вывода ошибок

#+NAME: macro_bprint
#+BEGIN_SRC lisp
  (defmacro bprint (var)
    `(subseq (with-output-to-string (*standard-output*)  (pprint ,var)) 1))
#+END_SRC

#+NAME: macro_err
#+BEGIN_SRC lisp
  (defmacro err (var)
    `(error (format nil "ERR:[~A]" (bprint ,var))))
#+END_SRC

* Отладочный вывод

#+NAME: dbgout
#+BEGIN_SRC lisp
  (defparameter *dbg-enable* t)
  (defparameter *dbg-indent* 1)

  (defun dbgout (out)
    (when *dbg-enable*
      (format t (format nil "~~%~~~AT~~A" *dbg-indent*) out)))

  (defmacro dbg (frmt &rest params)
    `(dbgout (format nil ,frmt ,@params)))
#+END_SRC

* Макросы для преобразования порядка аргументов

#+NAME: macro_clj
#+BEGIN_SRC lisp
  (defmacro -> (x &optional form &rest more)
    "Thread the expr through the forms. Insert X as the second item
  in the first form, making a list of it if it is not a list
  already. If there are more forms, insert the first form as the
  second item in second form, etc."
    (cond
      ((null form) x)
      ((null more) (if (listp form)
                       `(,(car form) ,x ,@(cdr form))
                       (list form x)))
      (:else `(-> (-> ,x ,form) ,@more))))

  ;; (-> 5 1- ODDP)
  ;; => (-> (-> 5 1-) ODDP)
  ;; => (ODDP (-> 5 1-))
  ;; => (ODDP (1- 5))

  ;; (sb-cltl2:macroexpand-all '(-> 'first (cons 'second) (cons 'third)))
  ;; => (CONS (CONS 'FIRST 'SECOND) 'THIRD)

  (defmacro ->> (x &optional form &rest more)
    "Thread the expr through the forms. Insert X as the last item
  in the first form, making a list of it if it is not a list
  already. If there are more forms, insert the first form as the
  last item in second form, etc."
    (cond
      ((null form) x)
      ((null more) (if (listp form)
                       `(,@form ,x)
                       (list form x)))
      (:else `(->> (->> ,x ,form) ,@more))))

  ;; (sb-cltl2:macroexpand-all '(->> 'first (cons 'second) (cons 'third)))
  ;; => (CONS 'THIRD (CONS 'SECOND 'FIRST))
#+END_SRC
