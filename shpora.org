* Интро
Моя шпоря по лексерам, грамматикам и прочим темам, необходимым для работы
над синтаксическим анализатором.

* Формальный язык и способы его описания. Формальная грамматика. Терминалы и нетерминалы.
https://habr.com/ru/post/177109/

** Формальный язык

Формальный язык - множество конечных слов (строк, цепочек) над конечным
алфавитом. Т.е. под формальный язык попадает и английский, и лисп, и си,
и китайский.

[[TODO:gmm]] интересно, есть ли языки, не попадающие под это определение?

** Формальная грамматика

Это способ описания формального языка, то есть выделения некоторого подмножества из множества
всех слов некоторого конечного алфавита.

Различают порождающие и распознающие (или аналитические) грамматики — первые задают правила, с
помощью которых можно построить любое слово языка, а вторые позволяют по
данному слову определить, входит ли оно в язык или нет.

Например порождающая грамматика задаст правило, что в русском языке слово
не может начинаться с мягкого знака. А аналитическая грамматика
определит, что если слово начинается с мягкого знака, то это точно не
русский язык.

** LL и LR грамматики

Допустим, у нас есть некое правило, что
формула -> число + число

Наш парсер парсит выражение 1+2. Встречает 1 и понимает, что это
число. Если это LL-грамматика, то встреченное число будет так подставлено
в правило: формула -> 1 + число, а если LR-грамматика, то так: формула ->
число + 2.


В LL грамматике парсер будет двигаться по лексическому дереву от корня к
листьям, в LR-грамматике - наоборот, от листьев к корню.


** Терминалы и нетерминалы

Терминал (терминальный символ) — объект, непосредственно присутствующий в
словах языка, соответствующего грамматике, и имеющий конкретное,
неизменяемое значение (обобщение понятия «буквы»). Обычно это латинские
буквы, цифры и спецсимволы.

Нетерминал (нетерминальный символ) — объект, обозначающий какую-либо
сущность языка и не имеющий конкретного символьного значения.

Не путать нетерминалы с группой терминалов, образующую лексмы
[[TODO:gmm]] defun в лиспе - это группа терминалов, образующая лексему, или
нетерминал?

** Ahead символы
Допустим, есть два и более правил. Мы считали символ и понимаем, что он
подходит ко многим правилам. Чтоб понять, по какой ветке парсинга идти
дальше - с каким правилом сопоставлять полученное на ввод - нужно считать
следующий символ, хотя мы еще и первый толком не распарсили.

Вот этот второй символ и будет ahead-символом.

Например, есть правила:
сложение -> число + число
умножение -> число * число
вычитание -> число - число
деление -> число / число

 На вход мы получаем выражение 1 + 2. Ясно, что 1 - это число. Но оно
 подходит ко всем 4 правилам. Тогда придется cчитать '+' и тогда понятно,
 что речь идет о сложении. Т.е. '+' в этом случае - это ahead-символ.

** Способы описания формального языка
Источник
https://shpargalum.ru/shpora-gos-povtas/teoriya-yazyikov-programmirovaniya-i-metodov-translyaczii/sposobyi-opisaniya-formalnyix-yazyikov.html

*** Формы Бэкуса - Наура
Цепочки языка (т.е. конечные последовательности символов - например,
любое слово - это цепочка языка) могут содержать метасимволы, имеющие
особое назначение. Метаязык, предложенный Бэкусом и Науром (БНФ) использует следующие обозначения:

- символ «::=» отделяет левую часть правила от правой (читается: «определяется как»);
- нетерминалы обозначаются произвольной символьной строкой, заключенной в угловые скобки «<» и «>»;
- терминалы - это символы, используемые в описываемом языке;
- правило может определять порождение нескольких альтернативных цепочек, отделяемых друг от друга символом вертикальной черты «|» (читается: «или»).

Для повышения удобства и компактности описаний, в расширенных БНФ вводятся следующие дополнительные конструкции (метасимволы):

- квадратные скобки «[» и «]» означают, что заключенная в них синтаксическая конструкция может отсутствовать;
- фигурные скобки «{» и «}» означают повторение заключенной в них синтаксической конструкции ноль или более раз;
- сочетание фигурных скобок и косой черты «{/» и «/}» используется для обозначения повторения один и более раз;
- круглые скобки «(» и «)» используются для ограничения альтернативных конструкций;
- кавычки используются в тех случаях, когда один из метасимволов нужно включить в цепочку обычным образом.

Пример 1.10. Правила, определяющие понятие «идентификатор» языка программирования, могут выглядеть следующим образом:
<буква> ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w |x | y | z
<цифра> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<идентификатор> ::= <буква> {<буква> | <цифра>}


*** Диаграмы Вирта
см в источнике

* Парсер
Как связаны грамматика и парсер? Граматика - это свод правил, парсер
должне проверить, соответствует ли строка этим правилам.


** Top-down-parcing (от корня к листьям)
Полная версия:
https://www.youtube.com/watch?v=MFufzIMhubA&t=404s

Краткая версия:
У нас есть иерархия терминальных и нетерминальных символов, которая
образуется из правил грамматики. Считывая первый символ, мы определяем,
что это, проходя по иерархии сверху вниз, записывая каждый узел в
иерархии. Если дошли до конца иерархии, а но не смогли понять, что это за
символ - это очевидно недопустимый символ, синтаксическая ошибка.

Если все окей, то мы вписываем прочитанный символ в стек (не область
память, но структура данных), затем считываем следующий символ и дальше
сопоставляем иерархию правил и получающееся дерево, вписывая в него все
новые элменты.

[[TODO:gmm]] Найти сборник упражнений, выбрать пару несложных и распарсить
несколько математических выражений, используя логику LALR-парсера,
записать на бумажке (дракон-схеме)
